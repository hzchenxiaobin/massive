### 多维grid

在CUDA中，一个grid中的所有线程执行相同的内核函数，并依靠坐标，即线程索引，来区分彼此并确定要处理的数据。正如我们在第2章《异构数据并行计算》中所看到的，这些线程被组织成一个两级层次结构：一个grid由一个或多个block组成，每个block由一个或多个线程组成。一个block中的所有线程共享相同的block索引，可以通过内置变量blockIdx访问。每个线程也有一个线程索引，可以通过内置变量threadIdx访问。当一个线程执行kernel函数时，对blockIdx和threadIdx变量的引用会返回该线程的坐标。在调用kernel的语句中的执行配置参数指定了grid的维度和每个block的维度，这些维度可以通过内置变量gridDim和blockDim获得。

一般来说，grid是一个三维（3D）的block数组，每个block是一个三维线程数组。在调用kernel时，程序需要指定grid的大小和每个维度中block的大小。这些通过kernel调用语句的执行配置参数（在 << < ... > > > 之间）指定。第一个执行配置参数指定grid在block数量上的维度。第二个指定每个block在线程数量上的维度。每个这样的参数都有dim3类型，这是一种包含三个元素x、y和z的整数向量类型。这三个元素指定了三个维度的大小。程序员可以通过将未使用维度的大小设置为1来使用少于三个维度。

以下是一个示例，展示如何在host代码中调用 `vecAddkernel()` kernel函数，并生成一个由32个块组成的1D的grid，每个block中包含128个线程。总的线程数是128 * 32 = 4096。

```c
dim3 dimGrid(32, 1, 1);
dim3 dimBlock(128, 1, 1);
vecAddKernel<<<dimGrid, dimBlock>>>(...);
```

`dimBlock` 和 `dimGrid` 是由程序员在host代码中定义的变量。这些变量可以使用任何合法的C语言变量名，只要它们的类型是 `dim3`。例如，以下语句实现的效果与上述语句相同：

```c
dim3 dog(32, 1, 1);
dim3 cat(128, 1, 1);
vecAddKernel<<<dog, cat>>>(...);
```

grid和block的维度也可以从其他变量计算得到。例如，代码2.12中的kernel调用可以如下所示编写：

```c
dim3 dimGrid(ceil(n/256.0), 1, 1);
dim3 dimBlock(128, 1, 1);
vecAddKernel<<<dimGrid, dimBlock>>>(...);
```

这种方式允许block的数量随着向量的大小变化，确保grid中有足够的线程覆盖所有向量元素。在这个例子中，程序员选择将块大小固定为256。在调用kernel时，变量 n 的值将决定grid的维度。例如，如果 n 等于1000，grid将包含四个block。如果 n 等于4000，grid将有16个block。在每种情况下，都会有足够的线程来覆盖所有的向量元素。一旦启动grid，grid和block的维度将保持不变，直到整个grid执行完成。

为方便起见，CUDA提供了一种特殊的快捷方式来使用一维（1D）grid和block调用kernel。可以使用算术表达式来指定一维grid和block的配置，而不是使用 `dim3` 变量。在这种情况下，CUDA编译器会简单地将算术表达式作为 x 维度，并假定 y 和 z 维度为1。这代码2.12中所示的kernel调用语句：

```c
vecAddKernel<<<ceil(n/256.0), 256>>>(...);
```

熟悉C++的读者会意识到，这种用于一维配置的“简化”约定利用了C++构造函数和默认参数的工作原理。dim3构造函数的参数默认值为1。当在期望dim3的地方传递单个值时，该值将传递给构造函数的第一个参数，而第二个和第三个参数将采用默认值1。一维grid或block，其中x维度的大小是传递的值，而y和z维度的大小为1。

在kernel函数中，变量 `gridDim` 和 `blockDim` 的 `x` 字段根据执行配置参数的值进行预初始化。例如，如果 `n` 等于4000，在 `vecAddkernel` 内核中引用 `gridDim.x` 和 `blockDim.x` 将分别得到16和256。需要注意的是，与host代码中的 `dim3` 变量不同，内核函数中这些变量的名称是CUDA C规范的一部分，不能更改。换句话说，`gridDim` 和 `blockDim` 是内核中的内置变量，始终反映grid和block的维度。

在CUDA C中，`gridDim.x` 的允许取值范围为1到2^31 - 1[^1]，而 `gridDim.y` 和 `gridDim.z` 的取值范围为1到2^16 - 1（即65,535）。每个block中的所有线程共享相同的 `blockIdx.x`、`blockIdx.y` 和 `blockIdx.z` 值。在不同的block之间，`blockIdx.x` 的值范围从0到 `gridDim.x - 1`，`blockIdx.y` 的值范围从0到 `gridDim.y - 1`，`blockIdx.z` 的值范围从0到 `gridDim.z - 1`。

现在我们将注意力转向block的配置。每个block都组织成一个三维线程数组。通过将 `blockDim.z` 设置为1，可以创建二维（2D）block。通过将 `blockDim.y` 和 `blockDim.z` 都设置为1，可以创建一维block，就像在 `vectorAddkernel` 示例中一样。正如我们之前提到的，grid中的所有block具有相同的维度和大小。每个block中每个维度的线程数量由内核调用时的第二个执行配置参数指定。在内核中，可以通过 `blockDim` 的 `x`、`y` 和 `z` 字段访问这些配置参数。

当前CUDA系统中，一个block的总线程数限制为1024个。这些线程可以在三个维度上以任何方式分布，只要总线程数不超过1024个。例如，`blockDim` 可以是 (512, 1, 1)，(8, 16, 4)，和 (32, 16, 2)，但是 (32, 32, 2) 是不允许的，因为总线程数会超过1024个。

<figure>
    <style>
     hr {
         border: none;
         height: 2px;
         background-color: black;
         margin: 5px auto;
     }
	</style>
    <img id="fig3.1" src="..\pic\chapter3\fig3.1.jpeg">
    <figcaption>
        <p class="no-indent" style="font-weight: bold;">
        图3.1
        </p>
       	<hr style="border: none; height: 2px; background-color: black; margin: 5px auto;">
        <p class="no-indent" style="font-family: 'Arial', 'Helvetica', sans-serif;color: #808080">
            CUDA多维grid示例。
        </p>
    </figcaption>
</figure>

grid和它的block不需要具有相同的维度。grid可以比它的block具有更高的维度，反之亦然。例如，[图3.1](#fig3.1)展示了一个小型grid示例，其中grid维度为 (2, 2, 1)，block维度为 (4, 2, 2)。可以使用以下host代码创建这样的网格：

```c
dim3 dimGrid(2, 1, 1);
dim3 dimBlock(4, 2, 2);
vecAddKernel<<<dimGrid, dimBlock>>>(...);
```











[^1]:当CUDA设备容量小于3.0的情况下，blockIdx.x的允许取值范围为1到2^16 - 1

