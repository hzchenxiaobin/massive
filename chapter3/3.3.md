### 3.3 图像模糊：一个更复杂的kernel

我们已经学习了 `vecAddkernel` 和 `colorToGrayscaleConversion`，其中每个线程只对一个数组元素执行少量的算术运算。这些kernel很好地实现了它们的目的：展示基本的 CUDA C 程序结构和数据并行执行的概念。在这一点上，读者应该问一个显而易见的问题：CUDA C 程序中的所有线程是不是只能独立地执行如此简单和琐碎的操作？答案是否定的。在实际的 CUDA C 程序中，线程通常对其数据执行复杂操作，并且需要彼此协作。在接下来的几章中，我们将研究一些日益复杂的示例，这些示例展示了这些特性。我们将从一个图像模糊函数开始。

<figure>
    <style>
     hr {
         border: none;
         height: 2px;
         background-color: black;
         margin: 5px auto;
     }
	</style>
    <img id="fig3.6" src="..\pic\chapter3\fig3.6.jpeg">
    <figcaption>
        <p class="no-indent" style="font-weight: bold;">
        图3.6
        </p>
       	<hr style="border: none; height: 2px; background-color: black; margin: 5px auto;">
        <p class="no-indent" style="font-family: 'Arial', 'Helvetica', sans-serif;color: #808080">
            原始图片(左边)和模糊版本(右边)
        </p>
    </figcaption>
</figure>

通过平滑像素值的突变来实现图像模糊，同时保留图像识别关键特征所必需的边缘。[图3.6](#fig3.6)展示了图像模糊的效果。简单来说，我们使图像变得模糊。在人眼看来，模糊的图像往往会模糊细节并呈现出“整体印象”或图像中的主要主题对象。在计算机图像处理算法中，图像模糊的一个常见用途是通过用干净的周围像素值校正问题像素值来减少图像中的噪声和颗粒渲染效应的影响。在计算机视觉中，图像模糊可以用于允许边缘检测和对象识别算法聚焦于主题对象，而不是被大量细粒度对象困扰。图像模糊有时被用来通过模糊图像的其他部分来突出图像的特定部分。

数学上，图像模糊函数计算输出图像像素值时，将输入图像中包含该像素的一个像素块的像素值作为加权和进行计算。如我们将在第7章《卷积》中学习的那样，这种加权和的计算属于卷积模式。在本章中，我们将采用一种简化的方法，通过取目标像素周围N×N像素块的简单平均值来实现模糊。为了简化算法，我们不会根据像素与目标像素的距离对任何像素值进行加权。在实际操作中，在卷积模糊方法（例如高斯模糊）中对像素值进行加权是非常常见的。

<figure>
    <style>
     hr {
         border: none;
         height: 2px;
         background-color: black;
         margin: 5px auto;
     }
	</style>
    <img id="fig3.7" src="..\pic\chapter3\fig3.7.jpeg">
    <figcaption>
        <p class="no-indent" style="font-weight: bold;">
        图3.7
        </p>
       	<hr style="border: none; height: 2px; background-color: black; margin: 5px auto;">
        <p class="no-indent" style="font-family: 'Arial', 'Helvetica', sans-serif;color: #808080">
            每个输出像素是输入图像中其周围像素以及自身的平均值。
        </p>
    </figcaption>
</figure>

[图 3.7](#fig3.7) 展示了使用 3x3的小块进行图像模糊处理的示例。在计算位于 (row, col) 位置的输出像素值时，我们看到小块是以位于 (row, col) 位置的输入像素为中心的。3x3小块跨越三行（row-1, row, row+1）和三列（col-1, col, col+1）。例如，计算位于 (25, 50) 处的输出像素时，九个像素的坐标分别是 (24, 49), (24, 50), (24, 51), (25, 49), (25, 50), (25, 51), (26, 49), (26, 50), 和 (26, 51)。

```c
__global__
void blurKernel(unsigned char *in, unsigned char *out, int w, int h) {
    int col = blockIdx.x * blockDim.x + threadIdx.x;
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    if (col < w && row < h) {
        int pixVal = 0;
        int pixels = 0;
        
        // Get average of the surrounding BLUR_SIZE x BLUR_SIZE box
        for (int blurRow=-BLUR_SIZE; blurRow < BLUR_SIZE + 1; ++blurRow) {
            for (int blurCol=-BLUR_SIZE; blurCol < BLUR_SIZE + 1; ++blurCol) {
                int curRow = row + blurRow;
                int curCol = col + blurCol;
                // Verify we have a valid image pixel
                if (curRow >=0 && curRow < h && curCol >= 0 && curCol < w) {
                    pixVal += in[curRow * w + curCol];
                    ++pixels;// Keep track of number of pixels in the avg
                }
            }
        }
        // Write our new pixel value out
        out[row * w + col] = (unsigned char)(pixVal / pixels);
    }
}
```

<figure>
    <style>
     hr {
         border: none;
         height: 2px;
         background-color: black;
         margin: 5px auto;
     }
	</style>
    <figcaption>
        <p class="no-indent" style="font-weight: bold;">
        图3.8
        </p>
       	<hr style="border: none; height: 2px; background-color: black; margin: 5px auto;">
        <p class="no-indent" style="font-family: 'Arial', 'Helvetica', sans-serif;color: #808080">
            模糊图片的kernel函数
        </p>
    </figcaption>
</figure>

图3.8展示了一个图像模糊的kernel函数。与在colorToGrayscaleConversion中使用的策略类似，我们使用每个线程来计算一个输出像素。换句话说，线程到输出数据的映射保持不变。因此，在kernel函数的开头我们看到了计算列和行索引的熟悉操作（第3到4行）。我们还看到了熟悉的if语句，用于验证列和行索引是否都在图像高度和宽度的有效范围内（第5行）。只有那些列和行索引都在有效范围内的线程才能参与执行。