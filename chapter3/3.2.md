### 3.2 将线程映射到多维数据



<figure>
    <style>
     hr {
         border: none;
         height: 2px;
         background-color: black;
         margin: 5px auto;
     }
	</style>
    <img id="fig3.2" src="..\pic\chapter3\fig3.2.jpeg">
    <figcaption>
        <p class="no-indent" style="font-weight: bold;">
        图3.2
        </p>
       	<hr style="border: none; height: 2px; background-color: black; margin: 5px auto;">
        <p class="no-indent" style="font-family: 'Arial', 'Helvetica', sans-serif;color: #808080">
            使用一个二维grid处理62 x 76的图片P
        </p>
    </figcaption>
</figure>
线程组织方式（1D、2D或3D）的选择通常基于数据的性质。例如，图片是二维像素数组。使用由2D的block组成的2D grid通常便于处理图片中的像素。[图3.2](#fig3.2)展示了这样一种处理 62 × 761F1F[^2] 图片 P 的排列方式（垂直方向或 y 方向有62个像素，水平方向或 x 方向有76个像素）。假设我们决定使用 16 × 16 的block，每个block在 x 方向和 y 方向上都有16个线程。我们在 y 方向需要四个block，在 x 方向需要五个block，总共 4 × 5 = 20 个block，如[图3.2](#fig3.2)所示。粗线标记了block的边界。阴影区域表示覆盖像素的线程。每个线程被分配处理一个像素，其 y 和 x 坐标从其 `blockIdx`、`blockDim` 和 `threadIdx` 变量值中得出：

垂直（行）坐标 = blockIdx.y * blockDim.y + threadIdx.y

水平（列）坐标 = blockIdx.x* blockDim.x + threadIdx.x

例如，要由block(1,0) 的线程 (0,0) 处理的 Pin元素可以这样标识：

Pin<sub>blockIdx.y * blockDim.y + threadIdx.y, blockIdx.x * blockDim.x + threadIdx.x</sub> = Pin<sub>1 * 16 + 0, 0 * 16 + 0</sub> = Pin<sub>16, 0</sub>

在[图3.2](#fig3.2)中，我们在y方向有两个额外的线程，在x方向有四个额外的线程。也就是说，我们将生成64 × 80个线程来处理62 × 76个像素。这类似于代码2.9中用四个256线程的block处理1000个元素向量的情况。代码2.10中的if语句用于防止额外的24个线程生效。同样，我们期望图片处理的kernel函数会有if语句来测试线程的垂直和水平索引是否在有效的像素范围内。

假设host代码使用整数变量 n 来记录 y 方向的像素数，使用另一个整数变量 m 来记录 x 方向的像素数。我们进一步假设输入图片数据已被复制到global memory，并可以通过指针变量 Pin_d 访问。输出图片已在device memory中分配，并可以通过指针变量 Pout_d 访问。以下host代码可以用于调用2D内核函数colorToGrayscaleConversion来处理图片，如下所示：

```c
dim3 dimGrid(ceil(m/16.0), ceil(n/16.0), 1);
dim3 dimBlock(16, 16, 1);
colorToGrayscaleConversion<<<dimGrid, dimBlock>>>(Pin_d, Pout_d, m, n);
```

在这个示例中，为了简单起见，我们假设block的维度固定为16 × 16。而grid的维度则取决于图片的维度。为了处理一张1500 × 2000（300万像素）的图片，我们将生成11750个block：在y方向上94个，在x方向上125个。在kernel函数中，引用 `gridDim.x`、`gridDim.y`、`blockDim.x` 和 `blockDim.y` 将分别得到 125、94、16 和 16。

在展示kernel代码之前，我们首先需要理解如何在C语言中访问动态分配的多维数组的元素。理想情况下，我们希望将 `Pin_d` 作为一个二维数组访问，其中位于第 `j` 行和第 `i` 列的元素可以通过 `Pin_d[j][i]` 访问。然而，ANSI C标准（CUDA C基于该标准开发）要求在编译时必须知道 `Pin` 的列数，才能将 `Pin` 作为二维数组访问。不幸的是，对于动态分配的数组，这个信息在编译时是未知的。实际上，使用动态分配数组的部分原因是为了允许这些数组的大小和维度在运行时根据数据大小变化。因此，动态分配的二维数组的列数信息在编译时是不可知的。这就要求程序员必须显式地将动态分配的二维数组线性化，或“展平”为等效的一维数组。

实际上，C语言中的所有多维数组都是线性化的。这是由于现代计算机使用“扁平”的内存空间（参见“内存空间”边栏）。对于静态分配的数组，编译器允许程序员使用更高维度的索引语法，如 `Pin_d[j][i]` 来访问其元素。在底层，编译器将这些数组线性化为等效的一维数组，并将多维索引语法翻译为一维偏移量。而对于动态分配的数组，由于在编译时缺乏维度信息，当前的CUDA C编译器将这种转换工作留给了程序员。

> #### 内存空间
>
> 内存空间是对现代计算机中处理器如何访问内存的一种简化视图。每个正在运行的应用程序通常都有一个与之关联的内存空间。应用程序需要处理的数据和为应用程序执行的指令存储在其内存空间中的位置。每个位置通常可以容纳一个字节，并具有一个地址。需要多个字节的变量——例如4字节的浮点数（float）和8字节的双精度浮点数（double）——存储在连续的字节位置中。当从内存空间访问数据值时，处理器会给出起始地址（起始字节位置的地址）和所需的字节数。
>
> 大多数现代计算机至少有4G个字节大小的位置，其中每个G是1,073,741,824（2^30）。所有位置都标有一个地址，范围从0到使用的最大数字。由于每个位置只有一个地址，我们说内存空间具有“扁平”的组织结构。因此，所有多维数组最终都被“扁平化”为等效的一维数组。虽然C程序员可以使用多维数组语法来访问多维数组的元素，但编译器会将这些访问转换为一个指向数组起始元素的基指针，以及从这些多维索引计算得出的一维偏移量。

[^2]: 我们将按照降序引用多维数据的维度：z 维度，然后是 y 维度，依此类推。例如，对于一张在垂直或 y 维度有 n 个像素，水平方向或 x 维度有 m 个像素的图片，我们将其称为 n × m 图片。这遵循 C 语言多维数组的索引约定。例如，我们可以将 P\[y][x]简写为 P<sub>y,x</sub> 来表示，便于在文本和图中使用。不幸的是，这种排序与在 gridDim 和 blockDim 维度中数据维度的排序相反。当我们基于多维数组定义线程网格的维度，并由线程处理该数组时，这种差异可能会特别令人困惑。
