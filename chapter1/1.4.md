### 1.4 并行编程的挑战

是什么让并行编程变得困难？有人曾说过，如果你不在乎性能，并行编程是非常容易的。你甚至可以在一小时内写出一个并行程序。但是，如果你不在乎性能，那为什么还要费心写并行程序呢？

本书讨论了在并行编程中实现高性能所面临的几个挑战。首先，设计与顺序算法具有相同算法（计算）复杂度的并行算法可能具有挑战性。许多并行算法执行的工作量与其顺序算法相同。然而，有些并行算法所做的工作量超过了顺序算法。实际上，有时它们可能做了如此多的额外工作，以至于在处理大型输入数据集时反而运行得更慢。这尤其成问题，因为快速处理大型输入数据集是并行编程的一个重要动机。

例如，许多现实世界的问题能够很自然地用数学递归来描述。并行化这些问题通常需要非直观的思考方式，并可能在执行过程中需要冗余工作。有一些重要的算法原语，如前缀和，可以促进将问题的顺序递归表述转换为更加并行的形式。我们将更正式地介绍工作效率(work efficiency)的概念，并将在第11章"前缀和（扫描）"中，使用重要的并行模式如前缀和来说明设计与顺序算法对应物具有相同计算复杂度的并行算法所涉及的方法和权衡。

其次，许多应用程序的执行速度受到内存访问延迟和/或吞吐量的限制。我们将这些应用程序称为memory bound；相比之下，compute bound的应用程序则受到每字节数据执行的指令数量的限制。在memory bound的应用程序中实现高性能并行执行通常需要采用提高内存访问速度的方法。我们将在第5章"内存架构和数据局部性"和第6章"性能考虑"中介绍内存访问的优化技术，并在几个关于并行模式和应用的章节中应用这些技术。

第三，并行程序的执行速度通常比其顺序对应程序对输入数据特征更敏感。许多现实世界的应用需要处理具有广泛变化特征的输入，如不规则或不可预测的数据大小和不均匀的数据分布。这些大小和分布的变化可能导致分配给并行线程的工作量不均，从而显著降低并行执行的效率。并行程序的性能有时会随这些特征而发生戏剧性的变化。我们将在介绍并行模式和应用的章节中，介绍用于规范化数据分布和/或动态调整线程数量的技术，以应对这些挑战。

第四，一些应用程序可以并行化，而几乎不需要不同线程之间的协作。这些应用程序通常被称为"天然并行"（embarrassingly parallel）。其他应用程序则需要线程之间相互协作，这就需要使用同步操作，如屏障或原子操作。这些同步操作会给应用程序带来开销，因为线程经常会发现自己在等待其他线程，而不是执行有用的工作。我们将在本书中讨论各种减少这种同步开销的策略。

幸运的是，这些挑战大多已经被研究人员解决。在不同应用领域之间也存在一些共同模式，使我们能够将在一个领域中得出的解决方案应用于其他领域的挑战。这是我们将在重要的并行计算模式和应用背景下介绍解决这些挑战的关键技术的主要原因。