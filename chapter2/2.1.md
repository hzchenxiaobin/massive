### 2.1 数据并行

当现代软件应用程序运行缓慢时，问题通常出在需要处理的数据量太大。图像处理应用程序处理具有数百万到万亿像素的图像或视频。科学应用程序使用数十亿个网格点来模拟流体动力学。分子动力学应用程序必须模拟数千到数十亿个原子之间的相互作用。航空公司调度涉及成千上万的航班、机组人员和机场登机口。这些像素、粒子、网格点、相互作用、航班等中的大多数通常可以独立处理。例如，在图像处理过程中，将彩色像素转换为灰度仅需要该像素的数据。模糊图像通过将每个像素的颜色与附近像素的颜色平均化，仅需要该小范围像素邻域的数据。即使是看似全局的操作，例如查找图像中所有像素的平均亮度，也可以分解为许多可以独立执行的较小计算。这种对不同数据块的独立评估是数据并行性(data parallelism)的基础。编写数据并行代码意味着围绕数据重新组织计算流程，使得我们可以并行执行结果独立的计算过程，以更快（通常快得多）地完成整体任务。

让我们通过一个颜色转换为灰度的示例来说明数据并行的概念。[图2.1](#fig2.1)展示了一张彩色图像（左侧），该图像由许多像素组成，每个像素包含一个红色、绿色和蓝色的分数值（r, g, b），这些值从0（黑色）到1（全强度）不等。

为了将彩色图像（[图2.1](#fig2.1)的左侧）转换为灰度图像（右侧），我们通过应用以下加权求和公式计算每个像素的亮度值L：
$$
L = r * 0.21 + g * 0.72 + b * 0.07
$$

<figure>
    <style>
     hr {
         border: none;
         height: 2px;
         background-color: black;
         margin: 5px auto;
     }
	</style>
    <img id="fig2.1" src="..\pic\chapter2\fig2.1.jpeg">
    <figcaption>
        <p class="no-indent" style="font-weight: bold;">
        图2.1
        </p>
       	<hr style="border: none; height: 2px; background-color: black; margin: 5px auto;">
        <p class="no-indent" style="font-family: 'Arial', 'Helvetica', sans-serif;color: #808080">
            将彩色图像转换为灰度图像。
        </p>
    </figcaption>
</figure>
> #### RGB彩色图像表示
>
> 在RGB表示中，图像中的每个像素存储为(r, g, b)值的元组。图像行的格式为(r g b) (r g b) … (r g b)，如以下概念图所示。每个元组指定了红色(R)、绿色(G)和蓝色(B)的混合。这意味着，对于每个像素，r、g和b值分别表示红色、绿色和蓝色光源在渲染像素时的强度（0表示暗，1表示全强度）。
>
> <img id="rgb" src="..\pic\chapter2\rgb.jpeg" alt="图1.1">
>
> 这三种颜色的实际允许混合在不同行业内指定的颜色空间中有所不同。在此，AdobeRGB颜色空间中三种颜色的有效组合显示为三角形的内部。每种混合的垂直坐标（y值）和水平坐标（x值）表示像素强度中应分配给绿色和红色的比例。像素强度的剩余部分（1-y-x）应分配给蓝色。为了渲染图像，每个像素的r、g、b值用于计算像素的总强度（亮度）以及混合系数（x, y, 1-y-x）。

如果我们将输入视为由RGB值组成的图像数组I，将输出视为对应的亮度值数组O，我们就得到了[如图2.2](#fig2.2)所示的简单计算结构。例如，通过根据上述公式计算I[0]中RGB值的加权和生成O[0]；通过计算I[1]中RGB值的加权和生成O[1]；通过计算I[2]中RGB值的加权和生成O[2]，依此类推。这些每像素的计算彼此之间没有依赖关系，都可以独立进行。显然，颜色到灰度的转换展示了丰富的数据并行性。当然，在完整应用中的数据并行性可能更为复杂，本书的大部分内容致力于教授发现和利用数据并行性所需的并行思维。

<figure>
    <style>
     hr {
         border: none;
         height: 2px;
         background-color: black;
         margin: 5px auto;
     }
	</style>
    <img id="fig2.2" src="..\pic\chapter2\fig2.2.jpeg">
    <figcaption>
        <p class="no-indent" style="font-weight: bold;">
        图片2.2
        </p>
       	<hr style="border: none; height: 2px; background-color: black; margin: 5px auto;">
        <p class="no-indent" style="font-family: 'Arial', 'Helvetica', sans-serif;color: #808080">
            图像到灰度转换中的数据并行性。像素可以独立计算。
        </p>
    </figcaption>
</figure>

> #### 任务并行 vs. 数据并行
>
> 数据并行并不是并行编程中唯一使用的并行类型。任务并行在并行编程中也被广泛使用。任务并行性通常通过应用程序的任务分解来实现。例如，一个简单的应用程序可能需要进行向量加法和矩阵向量乘法。每一个操作都是一个任务。如果这两个任务可以独立完成，则存在任务并行性。I/O和数据传输也是常见的任务来源。
>
> 在大型应用程序中，通常存在大量独立的任务，因此任务并行也更多。例如，在一个分子动力学模拟器中，自然任务列表包括振动力、旋转力、非键力的邻居识别、非键力、速度和位置以及基于速度和位置的其他物理属性。
>
> 一般来说，数据并行是并行程序可扩展性的主要来源。对于大型数据集，通常可以找到丰富的数据并行，从而能够利用大规模并行处理器，并使应用性能随着每代具有更多执行资源的硬件而增长。然而，任务并行性在实现性能目标方面也可以发挥重要作用。在介绍流时，我们将进一步讨论任务并行性。
