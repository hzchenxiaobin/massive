### 4.8 查询设备属性

我们对SM资源划分的讨论提出了一个重要问题：如何找到特定设备可用的资源量？当CUDA应用程序在系统上执行时，如何查找设备中的SM数量以及每个SM可以分配的块和线程数量？同样的问题也适用于其他种类的资源，其中一些我们尚未讨论。通常，许多现代应用程序被设计为在各种硬件系统上执行。应用程序通常需要查询底层硬件的可用资源和能力，以利用更强大的系统，同时弥补较弱系统的不足（参见“资源和能力查询”边栏）。

> #### 资源和能力查询
>
> 在日常生活中，我们经常查询环境中的资源和能力。例如，当我们预订酒店时，可以查看房间提供的设施。如果房间配备了吹风机，我们就不需要自己带一个。大多数美国的酒店房间都配有吹风机，而其他地区的许多酒店则没有。
>
> 一些亚洲和欧洲的酒店提供牙膏甚至牙刷，而大多数美国酒店则不提供。许多美国酒店提供洗发水和护发素，而其他大洲的酒店则通常只提供洗发水。
>
> 如果房间配备了微波炉和冰箱，我们可以把晚餐的剩菜带回酒店，期待第二天吃到。如果酒店有游泳池，我们可以带上泳衣，在商务会议后游泳。如果酒店没有游泳池但有健身房，我们可以带上跑鞋和运动服。一些高档的亚洲酒店甚至提供运动服！
>
> 这些酒店设施是酒店的属性，即资源和能力。经验丰富的旅行者会在酒店网站上查看这些属性，选择最符合自己需求的酒店，并更加高效和有效地打包行李。

每个CUDA设备SM中的资源量是设备计算能力的一部分。一般来说，计算能力等级越高，每个SM中可用的资源就越多。GPU的计算能力通常会随着代数的增加而提升。Ampere A100 GPU的计算能力为8.0。

在CUDA C中，host代码可以通过内置机制查询系统中可用设备的属性。CUDA运行时系统（设备驱动程序）提供了一个API函数 `cudaGetDeviceCount`，该函数返回系统中可用的CUDA设备数量。主机代码可以使用以下语句来找出可用的CUDA设备数量：

```c++
int devCount;
cudaGetDeviceCount(&devCount);
```

虽然这可能不太明显，但现代PC系统通常有两个或更多CUDA设备。这是因为许多PC系统配备了一个或多个“集成”GPU。这些GPU是默认的图形单元，提供基本的功能和硬件资源，用于执行现代窗口化用户界面的基本图形功能。大多数CUDA应用程序在这些集成设备上表现不佳。因此，主机代码需要遍历所有可用设备，查询它们的资源和能力，并选择那些资源足够以实现令人满意性能的设备。

CUDA运行时将系统中所有可用设备编号从0到`devCount-1`。它提供了一个API函数 `cudaGetDeviceProperties`，该函数返回指定编号设备的属性。例如，我们可以在主机代码中使用以下语句来遍历所有可用设备并查询它们的属性：

```c++
cudaDeviceProp devProp;
for(unsigned int i = 0; i < devCount; i++) {
	cudaGetDeviceProperties(&devProp, i);
	// Decide if device has sufficient 
	resources/capabilities
}
```

内置类型 `cudaDeviceProp` 是一个C结构体类型，其字段代表了CUDA设备的属性。有关该类型的所有字段，请参阅CUDA C编程指南。我们将讨论其中一些特别与执行资源分配给线程相关的字段。我们假设属性已存储在 `devProp` 变量中，该变量的字段由 `cudaGetDeviceProperties` 函数设置。如果读者选择为变量使用不同的名称，则需要在以下讨论中相应地替换变量名称。

顾名思义，字段 `devProp.maxThreadsPerBlock` 给出了在查询的设备中每个block允许的最大线程数。有些设备允许每个block最多1024个线程，而其他设备可能允许更少。未来的设备甚至可能允许每个block有超过1024个线程。因此，查询可用设备并确定哪些设备可以在每个block中允许足够数量的线程是一个好主意，以确保满足应用程序的需求。

设备中的SM数量由 `devProp.multiProcessorCount` 指定。如果应用程序需要多个SM以实现令人满意的性能，则应该检查这个属性。此外，设备的时钟频率可以在 `devProp.clockRate` 中找到。时钟频率和SM数量的组合可以很好地指示设备的最大硬件执行吞吐量。

host代码可以通过字段 `devProp.maxThreadsDim[0]`（x维度）、`devProp.maxThreadsDim[1]`（y维度）和 `devProp.maxThreadsDim[2]`（z维度）找到block在每个维度上允许的最大线程数。利用这些信息的一个示例是自动调优系统在评估底层硬件的最佳block维度时，设置block维度的范围。同样，host代码可以在字段 `devProp.maxGridSize[0]`（x维度）、`devProp.maxGridSize[1]`（y维度）和 `devProp.maxGridSize[2]`（z维度）中找到grid在每个维度上允许的最大block个数。典型的用途是确定一个grid是否可以有足够的线程来处理整个数据集，或者是否需要某种迭代方法。

字段 `devProp.regsPerBlock` 表示每个SM中可用的寄存器数量。这个字段在确定kernel是否可以在特定设备上实现最大占用率，或是否会受到寄存器使用限制时非常有用。注意，这个字段的名称有些误导。对于大多数计算能力等级，一个block可以使用的最大寄存器数确实与SM中可用的寄存器总数相同。然而，对于某些计算能力等级，一个block可以使用的最大寄存器数可能少于SM中总共可用的寄存器数。

我们也讨论过，warp的大小取决于硬件。warp的大小可以通过 `devProp.warpSize` 字段获得。

`cudaDeviceProp` 类型中还有许多其他字段。我们将在书中介绍这些字段时，逐步讨论它们反映的概念和功能。