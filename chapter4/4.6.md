### 4.6 Warp调度和延迟容忍

当线程被分配到SM时，通常分配给一个SM的线程数比SM中的核心数要多。也就是说，在任何时候每个SM的执行单元只能执行其分配到的一部分线程。在早期的GPU设计中，每个SM在任意时刻只能为单个warp执行一条指令。在最近的设计中，每个SM可以在任意时刻为少量的warp执行指令。无论哪种情况，硬件都只能为SM中的部分warp执行指令。那么，为什么需要将这么多的warp分配给一个SM，而它在任何时刻只能执行其中的一部分呢？答案是，这是GPU在处理诸如全局内存访问等长延迟操作时的一种容错机制。

当一个warp需要等待先前启动的长延迟操作的结果时，该warp不会被选中执行。相反，将选择另一个不再等待先前指令结果的驻留warp执行。如果有多个warp准备好执行，则使用优先机制选择一个warp执行。这种用其他线程的工作填补一些线程操作延迟时间的机制通常被称为“延迟容忍”或“延迟隐藏”（参见“延迟容忍”边栏）。

> #### 延迟容忍
>
> 延迟容忍在许多日常情境中是必要的。例如，在邮局，每个尝试寄包裹的人理想情况下应该在去服务柜台之前填好所有的表格和标签。然而，正如我们都经历过的，有些人会等到服务柜台后才开始填写表格和标签，并向柜员询问需要填哪种表格以及如何填写。
>
> 当服务柜台前排着长队时，最大化服务人员的工作效率是很重要的。让一个人在柜员面前填写表格，而其他人都在等待，这不是一个好方法。柜员应该在那个人填写表格的同时，帮助排队等待的下一个顾客。这些其他顾客已经“准备好了”，不应该被需要更多时间填写表格的顾客阻碍。
>
> 这就是为什么一个优秀的服务员会礼貌地请第一个顾客稍等到一旁填写表格，同时服务其他顾客。在大多数情况下，第一个顾客不会被要求重新排队，而是在完成表格后，服务员服务完当前顾客后，会尽快为他或她提供服务。
>
> 我们可以将这些邮局顾客视为warp，将服务员视为硬件执行单元。需要填写表格的顾客对应于一个依赖于长延迟操作的warp。

需要注意的是，warp 调度也用于容忍其他类型的操作延迟，例如流水线浮点运算和分支指令。如果周围有足够的 warp，硬件很可能会在任何时间找到一个 warp 来执行，从而在某些 warp 的指令等待这些长延迟操作的结果时充分利用执行硬件。选择准备好执行的 warp 不会在执行时间线上引入任何空闲或浪费时间，这被称为零开销线程调度（参见“线程、上下文切换和零开销调度”旁框）。通过 warp 调度，warp 指令的长时间等待时间被执行其他 warp 的指令“隐藏”。这种容忍长操作延迟的能力是 GPU 不像 CPU 那样将大量芯片面积用于缓存内存和分支预测机制的主要原因。因此，GPU 可以将更多芯片面积用于浮点执行和内存访问通道资源。

> #### 线程、上下文切换和零开销调度
>
> 基于冯·诺伊曼模型，我们已经准备好更深入地了解线程是如何实现的。现代计算机中的线程是一个程序以及该程序在冯·诺伊曼处理器上的执行状态。回想一下，一个线程由程序的代码、正在执行的代码中的指令以及其变量的值和数据结构组成。
>
> 在基于冯·诺伊曼模型的计算机中，程序的代码存储在内存中。程序计数器（PC）跟踪正在执行的程序指令的地址。指令寄存器（IR）包含正在执行的指令。寄存器和内存保存变量和数据结构的值。
>
> 现代处理器设计允许上下文切换，多个线程可以通过轮流执行来共享处理器的时间。通过仔细保存和恢复程序计数器（PC）值以及寄存器和内存的内容，我们可以暂停线程的执行并在以后正确恢复线程的执行。然而，在这些处理器中进行上下文切换时，保存和恢复寄存器内容可能会带来显著的执行时间开销。
>
> 零开销调度是指GPU能够将需要等待长延迟指令结果的warp置于休眠状态，并激活准备就绪的warp，而不会在处理单元中引入任何额外的空闲周期。传统的CPU会产生这样的空闲周期，因为从一个线程切换到另一个线程需要将执行状态（例如外出线程的寄存器内容）保存到内存，并从内存加载新线程的执行状态。GPU的流式多处理器（SM）通过在硬件寄存器中保存所有已分配warp的执行状态来实现零开销调度，因此在从一个warp切换到另一个warp时无需保存和恢复状态。

为了使延迟容忍有效，理想情况下，流式多处理器（SM）应该分配比其执行资源可以同时支持的线程多得多的线程，以最大限度地提高在任何时刻找到准备执行的warp的机会。例如，在Ampere A100 GPU中，一个SM有64个核心，但可以同时分配多达2048个线程。因此，在任何给定的时钟周期内，SM可以分配的线程数量最多是其核心数量的32倍。将线程过度分配给SM对于延迟容忍至关重要。这增加了当当前执行的warp遇到长延迟操作时找到另一个warp来执行的机会。